// -----------------------
// Author 1: Veronica Escobar A
// Codigo 1: 201922197
// Author 2 : Juan Miguel Vega C
// Codigo 2: 
//
// P2 - Lenguajes y Maquinas Seccion 2 2021-1
//------------------------------
//
// 
//-----------------------

using gold.structures.automaton.*
using gold.visualization.automaton.*

procedure main(args:String[]) begin
	
	//q4_estados
	q4_estados := {"q4_a", "q4_b", "q4_c" , "q4_d", "q4_e", "q4_f", "q4_g", "q4_h", "q4_i", "q4_j", "q4_k", "q4_l", "q4_m", "q4_n", "q4_o", "q4_p", "q4_q", "q4_r", "q4_s", "q4_t", "q4_u", "q4_v", "q4_w", "q4_x", "q4_y", "q4_z"}
	
	//Declaration of automata
	Q := {"q0", "q1", "q2", "q3"} ∪ q4_estados ∪ "err"
	Σ := ('a'‥'z')
	Γ := ('a'‥'z')
	q := "q0"
	F := Q
	
	//Definition of (Mealy || Moore) automata
	M := GDeterministicTransducer(Q,Σ,Γ,q,F,δ,g,h)
	
	//Show visual graph of automata
	GAutomataFrame.show(M)
	
end


/**
 * Transition function
 */
 //Nota : I typed los estado a ser strings para que gold no llorara cuando uso string methods
function δ(q: String,s) begin
	
	eAlph := ('a'‥'z') // Ver si se puede quitar esto y todos los s in alphabet . Creo que son redundantes tomando en cuenta que esto es tanto el alfabeto de entrada como el de salida
	
	 /**
	 * Case : q % 5 == 1
	 * Rule :  Coded with the next letter in the alphabet
	 */
	 if ((q == "q0") and (s in eAlph)) then
	 	return "q1"
	 	
	 /**
	 * Case : q % 5 == 2
	 * Rule :  Duplicates input letter
	 */
	 elseif ((q == "q1") and (s in eAlph)) then
	 	return "q2"
	 	
	 /**
	 * Case : q % 5 == 3
	 * Rule :  Coded with previous letter in the alphabet
	 */
	 elseif ((q == "q2") and (s in eAlph)) then
	 	return "q3"
	 
	 /**
	 * Case : q % 5 == 4
	 * Rule :  Not coded, outputs same letter as input
	 */
	 elseif ((q == "q3") and (s in eAlph)) then
	 	q4_nextLetterState : String = "q4_" + s // based on the input letter in s then it should transition to state q4_s
	 	return q4_nextLetterState 
	 	
	 /**
	 * Case : q % 5 == 0
	 * Rule :  Replaced by the letter that was read and the previous letter (Slight adjustment to automata plan, first print input symbol and then the previous one)
	 */
	 elseif (q.startsWith("q4_") and s in eAlph) then
	 	return "q0"
	 	
	 /**
	  * Caso de error
	  */
	 else
	 	return "err"
	 	
	 end

end

/**
 * Mealy Automata Output function
 */
function h(q,s) begin
	eAlph := ('a'‥'z')
	alph_str:String = "abcdefghijklmnopqrstuvwxyz"
	alph:char[] = alph_str.toCharArray()
	
	//Current symbol being handled (Also helps in case rule 4 is fullfiled)
	currChar:char = s
	
	//Get duplication of the current symbol in the case Rule 2 is fullfiled
	duplicateChar : String = currChar + currChar
	
	//Get the previous and next symbol of the sequence
	index: int = alph_str.indexOf(currChar)
	nextChar: char = ' ' //Filler (Considerar tener un symbolo de error para saber cuando la codificacion salio algo mal, auqnue no deberia ser posibel)
	prevChar: char = ' ' //Filler
	lastPos : int = alph.length -1 // gets to the last positon in the array. Corresponding to the letter Z
	
	//Calculates the next character or the previous character in case Rule 1 or 3 are fullfiled:
	if (index == 0) then
		prevChar = alph[lastPos]
		nextChar = alph[index + 1]
	elseif (index == lastPos) then
		prevChar = alph[index - 1]
		nextChar = alph[0]
	elseif((index != 0) and (index != lastPos)) then
		prevChar = alph[index - 1]
		nextChar = alph[index + 1]
	end
	
	//TODO: Creo que podemos quitar lo de s in eAlph porque ya tenemos todo basicamente ahi
	
	 /**
	 * Case : q % 5 == 1
	 * Rule :  Coded with the next letter in the alphabet
	 */
	 if (q == "q0" and s in eAlph) then
	 	return nextChar
	 
	 /**
	 * Case : q % 5 == 2
	 * Rule :  Duplicates input letter
	 */
	 elseif ( q == "q1" and s in eAlph) then
	 	return duplicateChar
	 
	 /**
	 * Case : q % 5 == 3
	 * Rule :  Coded with previous letter in the alphabet
	 */
	 elseif ( q == "q2" and s in eAlph) then
	 	return prevChar
	 
	 /**
	 * Case : q % 5 == 4
	 * Rule :  Not coded, outputs same letter as input
	 */
	 elseif (q == "q3" and s in eAlph) then
	 	return s
	 
	 /**
	 * Case : q % 5 == 0
	 * Rule :  Replaced by the letter that was read and the previous letter (Slight adjustment to automata plan, first print input symbol and then the previous one)
	 */
	 
		// Hay que tener cuidado haciendo este. Creo que hay una forma de optimizarlo si nos creamos un hashMap pero me toca pensarlo mejor.
		
		
	 /**
	  * Case of error. Nothing else worked so something went wrong
	  */
	 else
	 	return λ
	 	
	 end
	
end


/**
 * Moore AutomataOutput function
 */
function g(q) begin
	return λ //For P2 We wont be using a Moore Automata.
end