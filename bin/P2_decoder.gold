// -----------------------
// Author 1: Veronica Escobar A
// Codigo 1: 201922197
// Author 2 : Juan Miguel Vega C
// Codigo 2: 
//
// P2 - LyM Seccion 2 2021-1
//------------------------------
// 
// Task Statement: The purpose of this project is to use GOLD to define a finite state transducer to code and decode inputs. 
// 
// In this program we present a Mealy Automata that is able to decode the input
//-----------------------

using gold.structures.automaton.*
using gold.visualization.automaton.*

procedure main(args:String[]) begin
	
	//Declaration of automata
	Q := {"d0", "d1", "d2", "d3","d4", "d5", "d6", "err"} 
	Σ := ('a'‥'z')
	Γ := ('a'‥'z')
	q := "d0"
	F := Q
	
	//Definition of Mealy automata
	M := GDeterministicTransducer(Q,Σ,Γ,q,F,δ,g,h)
	
	//Show visual graph of automata
	GAutomataFrame.show(M)
	
end

/**
 * Transition function
 * In this case the module changes to 7. As a 5 letter string will be always converted into an output with 7 strings:
 */
function δ(q:String,s) begin
	alphabet = ('a'‥'z')
	stateId: String = "d" //This is to allow flexibility in the case they change the states
	
	//If in any state d(n) where 0< n < 6 then advance to next state d(n+1)
	if((!q.endsWith(6) and !q.endsWith("r"))  and s in alphabet ) then
		nextStateNumber: int = Integer.parseInt(q[1]) + 1
		return stateId.concat(Integer.toString(nextStateNumber))
		
	//If in d6 it circles back to d1
	elseif(q.endsWith(6) and s in alphabet) then 
		return stateId.concat("0") 
		
	//Next state is by default error state so if it doesnt go in the if or else if  then it sends the automaton to error state
	else
		return "err"
	end
end

/**
 * Mealy Automata Output function
 */
function h(q,s) begin
	eAlph := ('a'‥'z')
	alph_str:String = "abcdefghijklmnopqrstuvwxyz"
	alph:char[] = alph_str.toCharArray()
	
	//Current symbol being handled (Also helps in case rule 4 is fullfiled)
	currChar:char = s
	currCharAsString:String = Character.toString(s)
	
	//Get the previous and next symbol of the sequence
	index: int = alph_str.indexOf(currChar)
	nextChar: char = ' ' //Filler (Considerar tener un symbolo de error para saber cuando la codificacion salio algo mal, auqnue no deberia ser posibel)
	prevChar: char = ' ' //Filler
	lastPos : int = alph.length -1 // gets to the last positon in the array. Corresponding to the letter Z
	
	//Calculates the next character or the previous character in case Rule 1 or 3 are fullfiled:
	if (index == 0) then
		prevChar = alph[lastPos]
		nextChar = alph[index + 1]
	elseif (index == lastPos) then
		prevChar = alph[index - 1]
		nextChar = alph[0]
	elseif((index != 0) and (index != lastPos)) then
		prevChar = alph[index - 1]
		nextChar = alph[index + 1]
	end
	
	//--------
	//RULES
	//--------
	/**
	 * Case : q % 7 == 1
	 * Rule : Decode with previous letter of the alphabet
	 */
	if ( q == "d0" and s in eAlph) then
	 	return prevChar
	 	
	/**
	 * Case : q % 7 == 2 and q % 7 == 3
	 * Rule :  Decode by reading letters in pos 2 outputing it back, then ignore the repeated letter in pos 3
	 */
	elseif (q == "d1" and s in eAlph) then
	 	return s 
	
	elseif (q == "d2" and s in eAlph) then
	 	return λ
	
	/**
	 * Case : q % 7 == 4
	 * Rule :  Decode with next letter in the alphabet
	 */
	elseif (q == "d3" and s in eAlph) then
	 	return nextChar
	
	 /**
	 * Case : q % 7 == 5
	 * Rule :  No need to decode, just pring the same input letter
	 */
	 elseif (q == "d4" and s in eAlph) then
	 	return s
	
		
	 /**
	 * Case : q % 7 == 6 and q % 7 == 0
	 * Rule :  Replaced by the letter that was read and the previous letter (Slight adjustment to automata plan, first print input symbol and then the previous one)
	 */
	 elseif (q == "d5" and s in eAlph) then
	 	return s
	 	
	 elseif (q == "d6" and s in eAlph) then
	 	return λ
	
	 /**
	  * Caso de error
	  */
	  else
	  	return λ
	  end
end

/**
 * Moore AutomataOutput function
 */
function g(q) begin
	return λ //For P2 We wont be using a Moore Automata.
end