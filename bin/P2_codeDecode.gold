
using gold.**
         
//Declared outside in order that decoder and coder can read them  
var Alphabet
var alph_str:String
var alph:char[]
var lastPos : int 

procedure main(args:String[]) begin
	var sc:java.util.Scanner(System.$in)
	
    alph_str = "abcdefghijklmnopqrstuvwxyz"
    alph = alph_str.toCharArray()//no se si es redundante tener ('a'‥'z') y lo de toCharrArray. Toca probar si se puede reducir a uno
    lastPos = alph.length -1
    
    //Declare both input and output alphabet of coder and decoder
    Alphabet = ('a'‥'z')
    
    //Declare coder and decoder
    coder:=createCoder()
   	deCoder:=createDecoder()
   	
   	//Console (through this you can interact with coder and decoder)
   	consoleCodeDecode(coder,deCoder)
end

procedure consoleCodeDecode(C:ITransducer, D:ITransducer) begin
	var sc:java.util.Scanner(System.$in)
	currentInput: String = " "
	
	print "------------------------------------------------------------- "
	print "Welcome to Proyect 2: Coder-Decoder! \n"
		
	while currentInput != λ do
			
		print "------------------------------------------------------------- "
		print "Enter the string you want to use (empty stringto exit):"
		
		if currentInput != λ then
			
			currentInput := sc.nextLine()	
			
			if currentInput != λ then
				valid := false
				option:String = λ
				
				
              while !valid do
	               print ""			       
	              	print "What do you want to do with this string?"
			       	print "1. code"
			       	print "2. decode"
			       	print "3. code and decode"
		      		
		      		
		       		option := sc.nextLine()
		       		
		       		
		       		if option ∈ {"1","2","3"} then
		       			valid := true
		       		else
		       			print("You didnt select a valid Option, try again. \n")
		       		end
		       
		       end
		       
		       
		       
		       codedString:String = ""
		       deCodedString:String = ""
		       var isAccepted: boolean //Will always be true
		       
		       codedStrScript: String = "The Coded string was: "
		       deCodedStrScript: String = "The DeCoded string was: "
		       
		       //TODO: Se puede simplificar como en CD3_2 pero hay que intentar encontrar una forma menos chambona
		       
		       //OPTION 1: CODE
		       if option.equals("1") then
		       		isAccepted = C.acceptsString(currentInput) 
		       		codedString = C.getOutputString()
		       		print codedStrScript.concat(codedString)
		       		
		       	//OPTION 2: DECODE
		       else if option.equals("2") then
		       		isAccepted = D.acceptsString(currentInput) 
		       		deCodedString= D.getOutputString()
		       		print deCodedStrScript.concat(deCodedString)
		       		
		       	//OPTION 3: CODE AND DECODE
		       	else
		       		
		       		isAccepted = C.acceptsString(currentInput) 
		       		codedString = C.getOutputString()
		    		print codedStrScript.concat(codedString)
		    		
		       		isAccepted = D.acceptsString(codedString) 
		       		deCodedString= D.getOutputString()
		       		print deCodedStrScript.concat(deCodedString)
		       		
		       		isEqual: String = "The input string is " + (currentInput.equals(deCodedString)? "" : "not ") +  "equal to the decoded string"
		       		print "\n" + isEqual
		       		
		       end	
			end
		end
	end
end
end


//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//---------------------------------------------------------                        C    O    D   E   R                                             ---------------------------------------------------------
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function createCoder():ITransducer begin
	
	//q4_estados
	q4_estados := {"q4_a", "q4_b", "q4_c" , "q4_d", "q4_e", "q4_f", "q4_g", "q4_h", "q4_i", "q4_j", "q4_k", "q4_l", "q4_m", "q4_n", "q4_o", "q4_p", "q4_q", "q4_r", "q4_s", "q4_t", "q4_u", "q4_v", "q4_w", "q4_x", "q4_y", "q4_z"}
	
	//Declaration of automata
	Q := {"q0", "q1", "q2", "q3", "err"} ∪ q4_estados 
	Σ := Alphabet
	Γ := Alphabet
	q := "q0"
	F := Q
	
	//Creates Mealy  automata to decode
	return 	GDeterministicTransducer(Q,Σ,Γ,q,F,δCode,g,hCode)
end

/**
 * Transition function
 */
function δCode(q: String,s) begin
	
	eAlph := ('a'‥'z') // Ver si se puede quitar esto y todos los s in alphabet . Creo que son redundantes tomando en cuenta que esto es tanto el alfabeto de entrada como el de salida
	
	 /**
	 * Case : q % 5 == 1
	 * Rule :  Coded with the next letter in the alphabet
	 */
	 if ((q == "q0") and (s in eAlph)) then
	 	return "q1"
	 	
	 /**
	 * Case : q % 5 == 2
	 * Rule :  Duplicates input letter
	 */
	 elseif ((q == "q1") and (s in eAlph)) then
	 	return "q2"
	 	
	 /**
	 * Case : q % 5 == 3
	 * Rule :  Coded with previous letter in the alphabet
	 */
	 elseif ((q == "q2") and (s in eAlph)) then
	 	return "q3"
	 
	 /**
	 * Case : q % 5 == 4
	 * Rule :  Not coded, outputs same letter as input
	 */
	 elseif ((q == "q3") and (s in eAlph)) then
	 	q4_nextLetterState : String = "q4_" + s // based on the input letter in s then it should transition to state q4_s
	 	return q4_nextLetterState 
	 	
	 /**
	 * Case : q % 5 == 0
	 * Rule :  Replaced by the letter that was read and the previous letter (Slight adjustment to automata plan, first print input symbol and then the previous one)
	 */
	 elseif (q.startsWith("q4_") and s in eAlph) then
	 	return "q0"
	 	
	 /**
	  * Caso de error
	  */
	 else
	 	return "err"
	 	
	 end

end




function hCode(q: String,s) begin
	
	currCharAsString:String = Character.toString(s)//Current symbol being handled
	duplicateChar : String = currCharAsString.concat(Character.toString(s)) //Get duplication of the current symbol
	prevChar: char = getPrevChar(s) //Previous char in alphabet
	nextChar: char = getNextChar(s) //Next char in alphabet
	
	 /**
	 * Case : q % 5 == 1
	 * Rule :  Coded with the next letter in the alphabet
	 */
	 if (q == "q0") then
	 	return nextChar
	 
	 /**
	 * Case : q % 5 == 2
	 * Rule :  Duplicates input letter
	 */
	 elseif ( q == "q1") then
	 	return duplicateChar
	 
	 /**
	 * Case : q % 5 == 3
	 * Rule :  Coded with previous letter in the alphabet
	 */
	 elseif ( q == "q2") then
	 	return prevChar
	 
	 /**
	 * Case : q % 5 == 4
	 * Rule :  Not coded, outputs same letter as input
	 */
	 elseif (q == "q3") then
	 	return s
	 
	 /**
	 * Case : q % 5 == 0
	 * Rule :  Replaced by the letter that was read and the previous letter (Slight adjustment to automata plan, first print input symbol and then the previous one)
	 */
	 elseif ( q.startsWith("q4_")) then
		//Does loop arround the whole alphabet to check which state its in and returns the corresponding letter (the state contains informatin about the previous letter)
		for each letter in Alphabet do
			if( q.endsWith(letter)) then
				return currCharAsString.concat(Character.toString(letter))  //Concatenates current letter being passed , s, and the letter that was reviously passed , letter
			end
		end
		
	 /**
	  * Case of error. Nothing else worked so something went wrong
	  */
	 else
	 	return λ
	 	
	 end
	
end


//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//---------------------------------------------------------                      D    E    C    O    D   E   R                                    ---------------------------------------------------------
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function createDecoder():ITransducer begin
	//Declaration of automata
	Q := {"d0", "d1", "d2", "d3","d4", "d5", "d6", "err"} 
	Σ := Alphabet
	Γ := Alphabet
	q := "d0"
	F := Q

	return GDeterministicTransducer(Q,Σ,Γ,q,F,δDecode,g,hDecode)
end


/**
 * Transition function
 */
function δDecode(q:String,s) begin
	stateId: String = "d" 
	
	//If in any state d(n) where 0< n < 6 then advance to next state d(n+1)
	if((!q.endsWith(6) and !q.endsWith("r"))) then
		nextStateNumber: int = Integer.parseInt(q[1]) + 1
		return stateId.concat(Integer.toString(nextStateNumber))
		
	//If in d6 it circles back to d1
	elseif(q.endsWith(6)) then 
		return stateId.concat("0") 
		
	else
		return "err"
	end
end

/**
 * Mealy Automata Output function
 */
function hDecode(q,s) begin
	
	prevChar: char = getPrevChar(s) //Previous char in alphabet
	nextChar: char = getNextChar(s) //Next char in alphabet
	
	//Output function
	if q == "d0" then
	 	return prevChar
	elseif (q == "d1" or  q == "d4" or q == "d5") then
	 	return s 
	elseif q == "d3" then
	 	return nextChar
	else
	  	return λ
	 end
end
	
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//---------------------------------------------------------                     A U X I L I A R Y   F U N C T I O N S                  ---------------------------------------------------------
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	
/**
 * When given a character in the alphabet it gets the previous character in the alphabet. 
 * It treats the alphabet circularly, as in the previous character of a will be z
 */
function getPrevChar(currentChar:char) begin
	index: int = alph_str.indexOf(currentChar)
	return (index == 0) ? alph[lastPos] :alph[index - 1]
end

/**
 * When given a character in the alphabet it gets the next character in the alphabet
 *  It treats the alphabet circularly, as in the next character of z will be a
 */
function getNextChar(currentChar:char) begin
	index: int = alph_str.indexOf(currentChar)
	return (index == lastPos) ? alph[0] : alph[index + 1]
end

/**
 * Generalized Moore automata output function 
 * It doesnt do anything, we are using a mealy automata
 */
function g(q) begin
	return λ 
end