
using gold.**
         
//Declared outside in order that decoder and coder can read them  
var InputAlphabet
var OutputAlphabet

procedure main(args:String[]) begin
	var sc:java.util.Scanner(System.$in)
    
    //Declare both input and output alphabet of coder and decoder
    InputAlphabet = ('a'‥'z')
    OutputAlphabet = ('a'‥'z')
    
    
    //Declare coder and decoder
    //coder:=createCoder()
   	//deCoder:=createDecoder()
   	
   	//Console (through this you can interact with coder and decoder)
   	//consoleCodeDecode(coder,deCoder)
end

procedure consoleCodeDecode(C:ITransducer, D:ITransducer) begin
	var sc:java.util.Scanner(System.$in)
	currentInput: String = " "
	
	print "------------------------------------------------------------- "
	print "Welcome to Proyect 2: Coder-Decoder! \n"
		
	while currentInput != λ do
			
		print "------------------------------------------------------------- "
		print "Enter the string you want to use (empty stringto exit):"
		
		if currentInput != λ then
			
			currentInput := sc.nextLine()	
			
			if currentInput != λ then
				valid := false
				option:String = λ
				
				
              while !valid do
	              	print "What do you want to do with this string?"
			       	print "1. code"
			       	print "2. decode"
			       	print "3. code and decode"
		      		
		      		
		       		option := sc.nextLine()
		       		
		       		
		       		if option ∈ {"1","2","3"} then
		       			valid := true
		       		else
		       			print("You didnt select a valid Option, try again. \n")
		       		end
		       
		       end
		       
		       
		       
		       codedString:String = ""
		       deCodedString:String = ""
		       var isAccepted: boolean //Will always be true
		       
		       codedStrScript: String = "The Coded string was: "
		       deCodedStrScript: String = "The DeCoded string was: "
		       
		       //TODO: Se puede simplificar como en CD3_2 pero hay que intentar encontrar una forma menos chambona
		       
		       //OPTION 1: CODE
		       if option.equals("1") then
		       		isAccepted = C.acceptsString(currentInput) 
		       		codedString = C.getOutputString()
		       		print codedStrScript.concat(codedString)
		       		
		       	//OPTION 2: DECODE
		       else if option.equals("2") then
		       		isAccepted = D.acceptsString(currentInput) 
		       		deCodedString= D.getOutputString()
		       		print deCodedStrScript.concat(deCodedString)
		       		
		       	//OPTION 3: CODE AND DECODE
		       	else
		       		
		       		isAccepted = C.acceptsString(currentInput) 
		       		codedString = C.getOutputString()
		    		print codedStrScript.concat(codedString)
		    		
		       		isAccepted = D.acceptsString(currentInput) 
		       		deCodedString= D.getOutputString()
		       		print deCodedStrScript.concat(deCodedString)
		       		
		       		isEqual: String = "The input string is " + (currentInput.equals(deCodedString)? "" : "not ") +  "equal to the decoded string"
		       		print "\n" + isEqual
		       		
		       end	
			end
		end
	end
end
end


//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//---------------------------------------------------------                        C    O    D   E   R                                             ---------------------------------------------------------
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function createCoder():ITransducer begin
	
	//q4_estados
	q4_estados := {"q4_a", "q4_b", "q4_c" , "q4_d", "q4_e", "q4_f", "q4_g", "q4_h", "q4_i", "q4_j", "q4_k", "q4_l", "q4_m", "q4_n", "q4_o", "q4_p", "q4_q", "q4_r", "q4_s", "q4_t", "q4_u", "q4_v", "q4_w", "q4_x", "q4_y", "q4_z"}
	
	//Declaration of automata
	Q := {"q0", "q1", "q2", "q3", "err"} ∪ q4_estados 
	Σ := ('a'‥'z')
	Γ := ('a'‥'z')
	q := "q0"
	F := Q
	
	//Creates Mealy  automata to decode
	return 	GDeterministicTransducer(Q,Σ,Γ,q,F,δCode,gCode,hCode)
end

/**
 * Transition function
 */
 //Nota : I typed los estado a ser strings para que gold no llorara cuando uso string methods
function δCode(q: String,s) begin
	
	eAlph := ('a'‥'z') // Ver si se puede quitar esto y todos los s in alphabet . Creo que son redundantes tomando en cuenta que esto es tanto el alfabeto de entrada como el de salida
	
	 /**
	 * Case : q % 5 == 1
	 * Rule :  Coded with the next letter in the alphabet
	 */
	 if ((q == "q0") and (s in eAlph)) then
	 	return "q1"
	 	
	 /**
	 * Case : q % 5 == 2
	 * Rule :  Duplicates input letter
	 */
	 elseif ((q == "q1") and (s in eAlph)) then
	 	return "q2"
	 	
	 /**
	 * Case : q % 5 == 3
	 * Rule :  Coded with previous letter in the alphabet
	 */
	 elseif ((q == "q2") and (s in eAlph)) then
	 	return "q3"
	 
	 /**
	 * Case : q % 5 == 4
	 * Rule :  Not coded, outputs same letter as input
	 */
	 elseif ((q == "q3") and (s in eAlph)) then
	 	q4_nextLetterState : String = "q4_" + s // based on the input letter in s then it should transition to state q4_s
	 	return q4_nextLetterState 
	 	
	 /**
	 * Case : q % 5 == 0
	 * Rule :  Replaced by the letter that was read and the previous letter (Slight adjustment to automata plan, first print input symbol and then the previous one)
	 */
	 elseif (q.startsWith("q4_") and s in eAlph) then
	 	return "q0"
	 	
	 /**
	  * Caso de error
	  */
	 else
	 	return "err"
	 	
	 end

end




function hCode(q: String,s) begin
	eAlph := ('a'‥'z')
	alph_str:String = "abcdefghijklmnopqrstuvwxyz"
	alph:char[] = alph_str.toCharArray()
	
	//Current symbol being handled (Also helps in case rule 4 is fullfiled)
	currChar:char = s
	currCharAsString:String = Character.toString(s)
	
	//Get duplication of the current symbol in the case Rule 2 is fullfiled
	duplicateChar : String = currCharAsString.concat(currCharAsString)
	
	//Get the previous and next symbol of the sequence
	index: int = alph_str.indexOf(currChar)
	nextChar: char = ' ' //Filler (Considerar tener un symbolo de error para saber cuando la codificacion salio algo mal, auqnue no deberia ser posibel)
	prevChar: char = ' ' //Filler
	lastPos : int = alph.length -1 // gets to the last positon in the array. Corresponding to the letter Z
	
	//Calculates the next character or the previous character in case Rule 1 or 3 are fullfiled:
	if (index == 0) then
		prevChar = alph[lastPos]
		nextChar = alph[index + 1]
	elseif (index == lastPos) then
		prevChar = alph[index - 1]
		nextChar = alph[0]
	elseif((index != 0) and (index != lastPos)) then
		prevChar = alph[index - 1]
		nextChar = alph[index + 1]
	end
	
	//TODO: Creo que podemos quitar lo de s in eAlph porque ya tenemos todo basicamente ahi
	
	 /**
	 * Case : q % 5 == 1
	 * Rule :  Coded with the next letter in the alphabet
	 */
	 if (q == "q0" and s in eAlph) then
	 	return nextChar
	 
	 /**
	 * Case : q % 5 == 2
	 * Rule :  Duplicates input letter
	 */
	 elseif ( q == "q1" and s in eAlph) then
	 	return duplicateChar
	 
	 /**
	 * Case : q % 5 == 3
	 * Rule :  Coded with previous letter in the alphabet
	 */
	 elseif ( q == "q2" and s in eAlph) then
	 	return prevChar
	 
	 /**
	 * Case : q % 5 == 4
	 * Rule :  Not coded, outputs same letter as input
	 */
	 elseif (q == "q3" and s in eAlph) then
	 	return s
	 
	 /**
	 * Case : q % 5 == 0
	 * Rule :  Replaced by the letter that was read and the previous letter (Slight adjustment to automata plan, first print input symbol and then the previous one)
	 */
	 elseif ( q.startsWith("q4_") and s in eAlph) then
		//Does loop arround the whole alphabet to check which state its in and returns the corresponding letter (the state contains informatin about the previous letter)
		for each letter in eAlph do
			if( q.endsWith(letter)) then
				return currCharAsString.concat(Character.toString(letter))  //Concatenates current letter being passed , s, and the letter that was reviously passed , letter
			end
		end
		
	 /**
	  * Case of error. Nothing else worked so something went wrong
	  */
	 else
	 	return λ
	 	
	 end
	
end


/**
 * Moore AutomataOutput function
 */
function gCode(q) begin
	return λ //For P2 We wont be using a Moore Automata.
end


